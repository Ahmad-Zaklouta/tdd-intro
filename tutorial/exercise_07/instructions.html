<!DOCTYPE html>
<!-- saved from url=(0064)file:///C:/Users/Lars/AppData/Local/Temp/MarkdownPadPreview.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>instructions</title>

<style type="text/css">
/* GitHub stylesheet for MarkdownPad (http://markdownpad.com) */
/* Author: Nicolas Hery - http://nicolashery.com */
/* Version: b13fe65ca28d2e568c6ed5d7f06581183df8f2ff */
/* Source: https://github.com/nicolahery/markdownpad-github */

/* RESET
=============================================================================*/

html, body, div, span, applet, object, iframe, h1, h2, h3, h4, h5, h6, p, blockquote, pre, a, abbr, acronym, address, big, cite, code, del, dfn, em, img, ins, kbd, q, s, samp, small, strike, strong, sub, sup, tt, var, b, u, i, center, dl, dt, dd, ol, ul, li, fieldset, form, label, legend, table, caption, tbody, tfoot, thead, tr, th, td, article, aside, canvas, details, embed, figure, figcaption, footer, header, hgroup, menu, nav, output, ruby, section, summary, time, mark, audio, video {
  margin: 0;
  padding: 0;
  border: 0;
}

/* BODY
=============================================================================*/

body {
  font-family: Helvetica, arial, freesans, clean, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  color: #333;
  background-color: #fff;
  padding: 20px;
  max-width: 960px;
  margin: 0 auto;
}

body>*:first-child {
  margin-top: 0 !important;
}

body>*:last-child {
  margin-bottom: 0 !important;
}

/* BLOCKS
=============================================================================*/

p, blockquote, ul, ol, dl, table, pre {
  margin: 15px 0;
}

/* HEADERS
=============================================================================*/

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
}

h1 tt, h1 code, h2 tt, h2 code, h3 tt, h3 code, h4 tt, h4 code, h5 tt, h5 code, h6 tt, h6 code {
  font-size: inherit;
}

h1 {
  font-size: 28px;
  color: #000;
}

h2 {
  font-size: 24px;
  border-bottom: 1px solid #ccc;
  color: #000;
}

h3 {
  font-size: 18px;
}

h4 {
  font-size: 16px;
}

h5 {
  font-size: 14px;
}

h6 {
  color: #777;
  font-size: 14px;
}

body>h2:first-child, body>h1:first-child, body>h1:first-child+h2, body>h3:first-child, body>h4:first-child, body>h5:first-child, body>h6:first-child {
  margin-top: 0;
  padding-top: 0;
}

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0;
}

h1+p, h2+p, h3+p, h4+p, h5+p, h6+p {
  margin-top: 10px;
}

/* LINKS
=============================================================================*/

a {
  color: #4183C4;
  text-decoration: none;
}

a:hover {
  text-decoration: underline;
}

/* LISTS
=============================================================================*/

ul, ol {
  padding-left: 30px;
}

ul li > :first-child, 
ol li > :first-child, 
ul li ul:first-of-type, 
ol li ol:first-of-type, 
ul li ol:first-of-type, 
ol li ul:first-of-type {
  margin-top: 0px;
}

ul ul, ul ol, ol ol, ol ul {
  margin-bottom: 0;
}

dl {
  padding: 0;
}

dl dt {
  font-size: 14px;
  font-weight: bold;
  font-style: italic;
  padding: 0;
  margin: 15px 0 5px;
}

dl dt:first-child {
  padding: 0;
}

dl dt>:first-child {
  margin-top: 0px;
}

dl dt>:last-child {
  margin-bottom: 0px;
}

dl dd {
  margin: 0 0 15px;
  padding: 0 15px;
}

dl dd>:first-child {
  margin-top: 0px;
}

dl dd>:last-child {
  margin-bottom: 0px;
}

/* CODE
=============================================================================*/

pre, code, tt {
  font-size: 12px;
  font-family: Consolas, "Liberation Mono", Courier, monospace;
}

code, tt {
  margin: 0 0px;
  padding: 0px 0px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px;
}

pre>code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent;
}

pre {
  background-color: #f8f8f8;
  border: 1px solid #ccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px;
}

pre code, pre tt {
  background-color: transparent;
  border: none;
}

kbd {
    -moz-border-bottom-colors: none;
    -moz-border-left-colors: none;
    -moz-border-right-colors: none;
    -moz-border-top-colors: none;
    background-color: #DDDDDD;
    background-image: linear-gradient(#F1F1F1, #DDDDDD);
    background-repeat: repeat-x;
    border-color: #DDDDDD #CCCCCC #CCCCCC #DDDDDD;
    border-image: none;
    border-radius: 2px 2px 2px 2px;
    border-style: solid;
    border-width: 1px;
    font-family: "Helvetica Neue",Helvetica,Arial,sans-serif;
    line-height: 10px;
    padding: 1px 4px;
}

/* QUOTES
=============================================================================*/

blockquote {
  border-left: 4px solid #DDD;
  padding: 0 15px;
  color: #777;
}

blockquote>:first-child {
  margin-top: 0px;
}

blockquote>:last-child {
  margin-bottom: 0px;
}

/* HORIZONTAL RULES
=============================================================================*/

hr {
  clear: both;
  margin: 15px 0;
  height: 0px;
  overflow: hidden;
  border: none;
  background: transparent;
  border-bottom: 4px solid #ddd;
  padding: 0;
}

/* TABLES
=============================================================================*/

table th {
  font-weight: bold;
}

table th, table td {
  border: 1px solid #ccc;
  padding: 6px 13px;
}

table tr {
  border-top: 1px solid #ccc;
  background-color: #fff;
}

table tr:nth-child(2n) {
  background-color: #f8f8f8;
}

/* IMAGES
=============================================================================*/

img {
  max-width: 100%
}
</style>
<style type="text/css">
.highlight  { background: #ffffff; }
.highlight .c { color: #999988; font-style: italic } /* Comment */
.highlight .err { color: #a61717; background-color: #e3d2d2 } /* Error */
.highlight .k { font-weight: bold } /* Keyword */
.highlight .o { font-weight: bold } /* Operator */
.highlight .cm { color: #999988; font-style: italic } /* Comment.Multiline */
.highlight .cp { color: #999999; font-weight: bold } /* Comment.Preproc */
.highlight .c1 { color: #999988; font-style: italic } /* Comment.Single */
.highlight .cs { color: #999999; font-weight: bold; font-style: italic } /* Comment.Special */
.highlight .gd { color: #000000; background-color: #ffdddd } /* Generic.Deleted */
.highlight .gd .x { color: #000000; background-color: #ffaaaa } /* Generic.Deleted.Specific */
.highlight .ge { font-style: italic } /* Generic.Emph */
.highlight .gr { color: #aa0000 } /* Generic.Error */
.highlight .gh { color: #999999 } /* Generic.Heading */
.highlight .gi { color: #000000; background-color: #ddffdd } /* Generic.Inserted */
.highlight .gi .x { color: #000000; background-color: #aaffaa } /* Generic.Inserted.Specific */
.highlight .go { color: #888888 } /* Generic.Output */
.highlight .gp { color: #555555 } /* Generic.Prompt */
.highlight .gs { font-weight: bold } /* Generic.Strong */
.highlight .gu { color: #aaaaaa } /* Generic.Subheading */
.highlight .gt { color: #aa0000 } /* Generic.Traceback */
.highlight .kc { font-weight: bold } /* Keyword.Constant */
.highlight .kd { font-weight: bold } /* Keyword.Declaration */
.highlight .kp { font-weight: bold } /* Keyword.Pseudo */
.highlight .kr { font-weight: bold } /* Keyword.Reserved */
.highlight .kt { color: #445588; font-weight: bold } /* Keyword.Type */
.highlight .m { color: #009999 } /* Literal.Number */
.highlight .s { color: #d14 } /* Literal.String */
.highlight .na { color: #008080 } /* Name.Attribute */
.highlight .nb { color: #0086B3 } /* Name.Builtin */
.highlight .nc { color: #445588; font-weight: bold } /* Name.Class */
.highlight .no { color: #008080 } /* Name.Constant */
.highlight .ni { color: #800080 } /* Name.Entity */
.highlight .ne { color: #990000; font-weight: bold } /* Name.Exception */
.highlight .nf { color: #990000; font-weight: bold } /* Name.Function */
.highlight .nn { color: #555555 } /* Name.Namespace */
.highlight .nt { color: #000080 } /* Name.Tag */
.highlight .nv { color: #008080 } /* Name.Variable */
.highlight .ow { font-weight: bold } /* Operator.Word */
.highlight .w { color: #bbbbbb } /* Text.Whitespace */
.highlight .mf { color: #009999 } /* Literal.Number.Float */
.highlight .mh { color: #009999 } /* Literal.Number.Hex */
.highlight .mi { color: #009999 } /* Literal.Number.Integer */
.highlight .mo { color: #009999 } /* Literal.Number.Oct */
.highlight .sb { color: #d14 } /* Literal.String.Backtick */
.highlight .sc { color: #d14 } /* Literal.String.Char */
.highlight .sd { color: #d14 } /* Literal.String.Doc */
.highlight .s2 { color: #d14 } /* Literal.String.Double */
.highlight .se { color: #d14 } /* Literal.String.Escape */
.highlight .sh { color: #d14 } /* Literal.String.Heredoc */
.highlight .si { color: #d14 } /* Literal.String.Interpol */
.highlight .sx { color: #d14 } /* Literal.String.Other */
.highlight .sr { color: #009926 } /* Literal.String.Regex */
.highlight .s1 { color: #d14 } /* Literal.String.Single */
.highlight .ss { color: #990073 } /* Literal.String.Symbol */
.highlight .bp { color: #999999 } /* Name.Builtin.Pseudo */
.highlight .vc { color: #008080 } /* Name.Variable.Class */
.highlight .vg { color: #008080 } /* Name.Variable.Global */
.highlight .vi { color: #008080 } /* Name.Variable.Instance */
.highlight .il { color: #009999 } /* Literal.Number.Integer.Long */
.pl-c {
    color: #969896;
}

.pl-c1,.pl-mdh,.pl-mm,.pl-mp,.pl-mr,.pl-s1 .pl-v,.pl-s3,.pl-sc,.pl-sv {
    color: #0086b3;
}

.pl-e,.pl-en {
    color: #795da3;
}

.pl-s1 .pl-s2,.pl-smi,.pl-smp,.pl-stj,.pl-vo,.pl-vpf {
    color: #333;
}

.pl-ent {
    color: #63a35c;
}

.pl-k,.pl-s,.pl-st {
    color: #a71d5d;
}

.pl-pds,.pl-s1,.pl-s1 .pl-pse .pl-s2,.pl-sr,.pl-sr .pl-cce,.pl-sr .pl-sra,.pl-sr .pl-sre,.pl-src,.pl-v {
    color: #df5000;
}

.pl-id {
    color: #b52a1d;
}

.pl-ii {
    background-color: #b52a1d;
    color: #f8f8f8;
}

.pl-sr .pl-cce {
    color: #63a35c;
    font-weight: bold;
}

.pl-ml {
    color: #693a17;
}

.pl-mh,.pl-mh .pl-en,.pl-ms {
    color: #1d3e81;
    font-weight: bold;
}

.pl-mq {
    color: #008080;
}

.pl-mi {
    color: #333;
    font-style: italic;
}

.pl-mb {
    color: #333;
    font-weight: bold;
}

.pl-md,.pl-mdhf {
    background-color: #ffecec;
    color: #bd2c00;
}

.pl-mdht,.pl-mi1 {
    background-color: #eaffea;
    color: #55a532;
}

.pl-mdr {
    color: #795da3;
    font-weight: bold;
}

.pl-mo {
    color: #1d3e81;
}
.task-list {
padding-left:10px;
margin-bottom:0;
}

.task-list li {
    margin-left: 20px;
}

.task-list-item {
list-style-type:none;
padding-left:10px;
}

.task-list-item label {
font-weight:400;
}

.task-list-item.enabled label {
cursor:pointer;
}

.task-list-item+.task-list-item {
margin-top:3px;
}

.task-list-item-checkbox {
display:inline-block;
margin-left:-20px;
margin-right:3px;
vertical-align:1px;
}
</style>
<!--<base href="file:\\\D:\tutorial\exercises\exercise_07\">--><base href=".">
</head>
<body>
<h1>Exercise 07</h1>
<h2>Purpose</h2>
<ul>
<li>Learn how to use VUnit verification components</li>
<li>Learn some basic concepts for VUnit message passing</li>
</ul>
<p>After this exercise you will be able to use VUnit to control common standard interfaces. You will also understand how VUnit can manage multiple DUT interfaces in parallel.</p>
<p>More information on this topic can be found in the <a href="http://vunit.github.io/verification_components/user_guide.html" rel="nofollow">verification component user guide</a> and in this <a href="https://www.linkedin.com/pulse/vunit-bfms-simple-emailing-lars-asplund" rel="nofollow">LinkedIn article</a>.</p>
<h2>Instructions</h2>
<ul>
<li>
<p>The incrementer presented in exercise 05 and 06 is based on AXI interfaces. AXI stream for input and output data and AXI Lite for a control interface which we didn't use in previous exercises. This exercise will raise the abstraction of previous testbenches by using VUnit bus functional models (BFM) rather than controlling the interfaces at the lowest bit level. Open <code>exercise_07/test/tb_bfm.vhd</code>. At the bottom of the testbench you'll find three BFMs:</p>
<ul>
<li><code>axi_stream_master</code> which connects to the input AXI stream on the incrementer.</li>
<li><code>axi_stream_slave</code> which connects to the output AXI stream on the incrementer.</li>
<li><code>axi_lite_master</code> which connects to the incrementer AXI Lite control bus.</li>
</ul>
<p>All these BFMs have a single generic, a handle, which provides the configuration of the BFM as well as gives the BFM instance a unique identifier in case we have several instances of the same BFM. All handles are created at the top of the testbench.</p>
<div class="highlight highlight-source-vhdl"><pre>  <span class="pl-k">constant</span> stream_data_length : <span class="pl-c1">positive</span>            <span class="pl-k">:=</span> <span class="pl-c1">16</span>;
  <span class="pl-k">constant</span> ctrl_data_length   : <span class="pl-c1">positive</span>            <span class="pl-k">:=</span> <span class="pl-c1">32</span>;

  <span class="pl-k">constant</span> axi_stream_slave   : axi_stream_slave_t  <span class="pl-k">:=</span> new_axi_stream_slave(data_length <span class="pl-k">=&gt;</span> stream_data_length,
                                                                            actor <span class="pl-k">=&gt;</span> new_actor(<span class="pl-s"><span class="pl-pds">"</span>AXI Stream Slave<span class="pl-pds">"</span></span>));
  <span class="pl-k">constant</span> axi_stream_master  : axi_stream_master_t <span class="pl-k">:=</span> new_axi_stream_master(data_length <span class="pl-k">=&gt;</span> stream_data_length,
                                                                            actor <span class="pl-k">=&gt;</span> new_actor(<span class="pl-s"><span class="pl-pds">"</span>AXI Stream Master<span class="pl-pds">"</span></span>));
  <span class="pl-k">constant</span> ctrl_bus           : bus_master_t        <span class="pl-k">:=</span> new_bus(data_length <span class="pl-k">=&gt;</span> ctrl_data_length,
                                                               address_length <span class="pl-k">=&gt;</span> <span class="pl-c1">8</span>,
                                                               actor <span class="pl-k">=&gt;</span> new_actor(<span class="pl-s"><span class="pl-pds">"</span>AXI Lite Master<span class="pl-pds">"</span></span>));</pre></div>
<p>To communicate with our BFMs we use the message passing paradigm under the hood. You can think of message passing as sending emails and the actor created above with <code>new_actor</code> is the email address for the BFM.</p>
<p>The only test case in the testbench is similar to what we had in exercise 06</p>
<div class="highlight highlight-source-vhdl"><pre>      <span class="pl-k">if</span> run(<span class="pl-s"><span class="pl-pds">"</span>Test DUT with random data<span class="pl-pds">"</span></span>) <span class="pl-k">then</span>
        n_samples <span class="pl-k">:=</span> rnd.RandInt(<span class="pl-c1">5</span>, <span class="pl-c1">10</span>);

        push(q, increment);
        push(q, n_samples);

        info(<span class="pl-s"><span class="pl-pds">"</span>Number of samples to push: <span class="pl-pds">"</span></span> <span class="pl-k">&amp;</span> to_string(n_samples));
        <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span> <span class="pl-k">to</span> n_samples <span class="pl-k">loop</span>
          input_data <span class="pl-k">:=</span> rnd.RandSlv(input_data<span class="pl-k">'length</span>);
          push(q, input_data);
          push_stream(net, as_stream(axi_stream_master), input_data);
        <span class="pl-k">end</span> <span class="pl-k">loop</span>;
        info(<span class="pl-s"><span class="pl-pds">"</span>Done pushing!<span class="pl-pds">"</span></span>);

        <span class="pl-k">wait</span> <span class="pl-k">until</span> check_done;
      <span class="pl-k">end</span> <span class="pl-k">if</span>;</pre></div>
<p>The important differences are that we're pushing the increment used by the incrementer (+1) into the queue used by the <code>check_output</code> to verify the output stream. The increment can be changed using the control bus and we'll do that later.</p>
<p>We have also introduced a new procedure</p>
<div class="highlight highlight-source-vhdl"><pre>push_stream(net, as_stream(axi_stream_master), input_data);</pre></div>
<p>This call will take the randomized <code>input_data</code> and send that to the <code>axi_stream_master</code> BFM telling it to push the <code>input_data</code> into the connected input stream. The sending of information to the BFM is done using message passing and you can think of the <code>net</code> parameter as the network over which these emails are sent.</p>
<p>The reason for using <code>as_stream(axi_stream_master)</code> rather than just <code>axi_stream_master</code> is that <code>push_stream</code> is a generic procedure that can be used by other BFMs handling a streaming interface, A BFM driving a UART for example. The <code>as_stream</code> function will return the generic parts of <code>axi_stream_master</code> such that the generic <code>push_stream</code> procedure can be reused.</p>
<p>Before and after the for loop are two <code>info</code> statements. Run the testbench with the verbose flag and notice the time stamps.</p>
<div class="highlight highlight-text-shell-session"><pre><span class="pl-c1">python run.py -v</span></pre></div>
<p>Note that it takes no simulation time to send the <code>push_stream</code> commands to the BFM. All messages will be queued in the BFM inbox and the BFM will process the messages one by one and apply the data back-to-back on the incrementer input.</p>
</li>
<li>
<p>The <code>check_output</code> process has also been updated</p>
<div class="highlight highlight-source-vhdl"><pre>check_output : <span class="pl-k">process</span> <span class="pl-k">is</span>
  <span class="pl-k">variable</span> data : <span class="pl-c1">std_logic_vector</span>(stream_data_length <span class="pl-k">-</span> <span class="pl-c1">1</span> <span class="pl-k">downto</span> <span class="pl-c1">0</span>);
  <span class="pl-k">variable</span> increment : <span class="pl-c1">integer</span>;
<span class="pl-k">begin</span>
  <span class="pl-k">wait</span> <span class="pl-k">on</span> clk <span class="pl-k">until</span> <span class="pl-k">not</span> is_empty(q);
  increment <span class="pl-k">:=</span> pop(q);

  <span class="pl-k">for</span> i <span class="pl-k">in</span> <span class="pl-c1">1</span> <span class="pl-k">to</span> pop(q) <span class="pl-k">loop</span>
    pop_stream(net, as_stream(axi_stream_slave), data);
    check_equal(data, pop_std_ulogic_vector(q) <span class="pl-k">+</span> increment, result(<span class="pl-s"><span class="pl-pds">"</span>for output_tdata<span class="pl-pds">"</span></span>));
    <span class="pl-k">wait</span> <span class="pl-k">for</span> rnd.RandTime(<span class="pl-c1">0</span> <span class="pl-c1">ns</span>, <span class="pl-c1">3</span> <span class="pl-k">*</span> clk_period, clk_period);
  <span class="pl-k">end</span> <span class="pl-k">loop</span>;

  check_done <span class="pl-k">&lt;=</span> <span class="pl-c1">true</span>;
<span class="pl-k">end</span> <span class="pl-k">process</span>;</pre></div>
<p>A <code>pop_stream</code> call has been added to tell the AXI stream slave to get us a new <code>data</code> from the output of the incrementer. <code>pop_stream</code> will send a message to the BFM with this instruction and once new data is available on the stream the BFM will send a reply message which <code>pop_stream</code> reads to set <code>data</code> and then return.</p>
<p>You can get a view of the communication taking place. VUnit has a <code>com_logger</code> used for tracing of message events and you can make that information visible by adding the following <code>show</code> statement:</p>
<div class="highlight highlight-source-vhdl"><pre>test_runner_setup(runner, runner_cfg);
rnd.InitSeed(rnd'instance_name);

show(com_logger, display_handler, trace);</pre></div>
<p>Re-run the test and you will see events like this</p>
<div class="highlight highlight-text-shell-session"><pre><span class="pl-e">[1:- - -&gt; AXI Stream Master (stream push)] =</span>&gt; <span class="pl-s1">AXI Stream Master inbox</span></pre></div>
<p>which means that a message (everything between [ and ]) with ID = 1, destination "AXI Stream Master" and of type "stream push" was written in (=&gt;) AXI Stream Master's inbox. You will see that all pushed messages happened without simulation time passing.</p>
<p>Then you will see events like these</p>
<div class="highlight highlight-text-shell-session"><pre><span class="pl-c1">AXI Stream Master inbox =&gt; [1:- - -&gt; AXI Stream Master (stream push)]</span></pre></div>
<p>which represents the same messages being read from the inbox when the BFM starts processing them.</p>
<p>You will also see that the <code>check_output</code> process requesting data from the AXI stream slave and that that message is processed by that BFM</p>
<div class="highlight highlight-text-shell-session"><pre><span class="pl-e">[11:- - -&gt; AXI Stream Slave (stream pop)] =</span>&gt; <span class="pl-s1">AXI Stream Slave inbox</span>
<span class="pl-c1">AXI Stream Slave inbox =&gt; [11:- - -&gt; AXI Stream Slave (stream pop)]</span></pre></div>
<p>Once the BFM has a new data it will reply back to the <code>pop_stream</code> procedure in <code>check_output</code></p>
<div class="highlight highlight-text-shell-session"><pre><span class="pl-e">[12:11 AXI Stream Slave -&gt; - (-)] =</span>&gt; <span class="pl-s1">AXI Stream Slave outbox</span></pre></div>
<p>Message 12 is a reply to message 11 (12:11) but since message 11 was from an anonymous sender (we haven't created an actor for <code>check_output</code>) the AXI stream slave will place the message in its own outbox from which the <code>pop_stream</code> procedure will read the reply.</p>
<div class="highlight highlight-text-shell-session"><pre><span class="pl-c1">AXI Stream Slave outbox =&gt; [12:11 AXI Stream Slave -&gt; - (-)]</span></pre></div>
<p>There is no privacy in message passing!</p>
<p>Remove the <code>show</code> statement to get a cleaner log.</p>
</li>
<li>
<p>Go back to the <code>test_runner</code> process. All <code>push_stream</code> commands were performed without waiting for them to complete. However, it is possible to wait for the BFM to complete all <code>push_stream</code> commands issued so far before proceeding. Insert this line after the loop just before the last info statement and re-run the test.</p>
<div class="highlight highlight-source-vhdl"><pre>wait_until_idle(net, as_sync(axi_stream_master));</pre></div>
<p>You should now see a time difference between the two logs.</p>
<p><code>wait_until_idle</code> will send a message to the BFM which the BFM will reply to once it's idle. When the reply is received <code>wait_until_idle</code> will return. A BFM can define what being idle means but a typical implementation is to reply to the message immediately when all preceding messages have been consumed. <code>wait_until_idle</code> is also a standard procedure that most verification components can provide to support synchronization of activities. Just like we used <code>as_stream</code> with standard stream operations we use <code>as_sync</code> with standard synchronization operations.</p>
</li>
<li>
<p>So far, we've been pushing input data back-to-back but that's not always what we want. In exercise 06 we had a random delay between every data in the stream and to do that with BFMs we can send a command putting it to sleep for a while. Add the following line after the <code>push_stream</code> call:</p>
<div class="highlight highlight-source-vhdl"><pre>wait_for_time(net, as_sync(axi_stream_master), rnd.RandTime(<span class="pl-c1">0</span> <span class="pl-c1">ns</span>, <span class="pl-c1">3</span> <span class="pl-k">*</span> clk_period, clk_period));</pre></div>
<p><code>wait_for_time</code> is another standard synchronization command and if you re-run the test you should see an increased delay between the time stamps.</p>
</li>
<li>
<p>The purpose of sending asynchronous messages that takes no simulation time is that you can control multiple interfaces in parallel from the same process. Having a single process coordinating all activities makes it easier to understand what the test is doing.</p>
<p>To test that we're going to randomize the increment and write that to the incrementer while data is being pushed on its input. First randomize the increment by updating the beginning of the test case</p>
<div class="highlight highlight-source-vhdl"><pre>  <span class="pl-k">if</span> run(<span class="pl-s"><span class="pl-pds">"</span>Test DUT with random data<span class="pl-pds">"</span></span>) <span class="pl-k">then</span>
    increment <span class="pl-k">:=</span> rnd.RandInt(<span class="pl-c1">0</span>, <span class="pl-c1">255</span>);
    n_samples <span class="pl-k">:=</span> rnd.RandInt(<span class="pl-c1">5</span>, <span class="pl-c1">10</span>);</pre></div>
<p>Then write the new value by adding a <code>write_bus</code> call</p>
<div class="highlight highlight-source-vhdl"><pre>      push(q, increment);
      push(q, n_samples);

      write_bus(net, ctrl_bus, increment_reg_addr, to_slv(increment, ctrl_data_length));</pre></div>
<p><code>write_bus</code> takes the <code>ctrl_bus</code> handle of our AXI Lite master BFM and commands it to perform a write to address <code>increment_reg_addr</code> (a constant set to 0). The value to write is the increment converted to a std_logic_vector.</p>
<p>Re-run your test.</p>
<p>You should get an error because the new increment didn't get written before the first input data was processed by the incrementer. In this case we don't really want the concurrency so you should update your code:</p>
<div class="highlight highlight-source-vhdl"><pre>write_bus(net, ctrl_bus, increment_reg_addr, to_slv(increment, data_length(ctrl_bus)));
wait_until_idle(net, as_sync(ctrl_bus));</pre></div>
<p>Re-run and it should pass.</p>
</li>
<li>
<p>Instead of doing a concurrent write operation we can try a concurrent read operation. Update your code to the following:</p>
<div class="highlight highlight-source-vhdl"><pre>write_bus(net, ctrl_bus, increment_reg_addr, to_slv(increment, data_length(ctrl_bus)));
wait_until_idle(net, as_sync(ctrl_bus));

read_bus(net, ctrl_bus, increment_reg_addr, ctrl_data);
info(<span class="pl-s"><span class="pl-pds">"</span>Increment is <span class="pl-pds">"</span></span> <span class="pl-k">&amp;</span> to_string(<span class="pl-c1">to_integer</span>(ctrl_data)));</pre></div>
<p>Run the test and you will see the randomized value of the increment.</p>
<p>The problem is that a read operation is inherently blocking. <code>read_bus</code> will send a message to the BFM instructing it to perform a read of address <code>increment_reg_addr</code> and then wait for a reply message containing the value read. Once the reply is received the value is placed in <code>ctrl_data</code> and the procedure returns.</p>
</li>
<li>
<p>To really test that it's possible to read a register while streaming data we need to send the read message to the BFM, then proceed to start streaming data and then, at some later point in time, have a look at the reply message from the BFM. To do that we need to use a read operation that doesn't wait for the data but allow you to check that reply later. Replace the two last lines with</p>
<div class="highlight highlight-source-vhdl"><pre>read_bus(net, ctrl_bus, increment_reg_addr, reference);</pre></div>
<p>Rather than returning the data this procedure will just send the read command to the BFM and then return a reference which allow you to fetch the reply later. Let's fetch the data after the loop</p>
<div class="highlight highlight-source-vhdl"><pre>info(<span class="pl-s"><span class="pl-pds">"</span>Done pushing!<span class="pl-pds">"</span></span>);

await_read_bus_reply(net, reference, ctrl_data);
info(<span class="pl-s"><span class="pl-pds">"</span>Increment is <span class="pl-pds">"</span></span> <span class="pl-k">&amp;</span> to_string(<span class="pl-c1">to_integer</span>(ctrl_data)));</pre></div>
<p>Re-run the test and you should see the same value. The difference is that the read operation was performed concurrently with the data streaming.</p>
</li>
</ul>


<!-- This document was created with MarkdownPad, the Markdown editor for Windows (http://markdownpad.com) -->
</body></html>